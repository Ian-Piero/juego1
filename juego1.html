<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake - Juego Simple (index.html)</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1724;
    --accent:#00d1b2;
    --text:#e6eef6;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071021 0%, #0b1220 100%);color:var(--text);padding:16px}
  .wrap{width:100%;max-width:720px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 6px 30px rgba(0,0,0,0.6);}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  h1{font-size:18px;margin:0}
  .score{font-weight:700;color:var(--accent)}
  canvas{width:100%;background:linear-gradient(180deg,#0b1630,#071226);display:block;border-radius:8px;touch-action: none;}
  .controls{display:flex;align-items:center;justify-content:space-between;margin-top:12px;gap:12px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  .btn.secondary{border-color:rgba(255,255,255,0.04);opacity:0.9}
  .touch-controls{display:none;flex-direction:column;gap:8px;align-items:center}
  .dpad{display:grid;grid-template-columns:repeat(3,56px);gap:6px}
  .dpad button{width:56px;height:56px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.01);font-size:18px}
  .hint{font-size:13px;opacity:0.8}
  footer{margin-top:10px;font-size:12px;color:rgba(255,255,255,0.6)}
  @media (max-width:640px){
    .touch-controls{display:flex}
    .controls-left{display:none}
  }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Snake juego simple">
    <header>
      <h1>Snake — Juego simple</h1>
      <div class="score">Puntos: <span id="score">0</span></div>
    </header>

    <canvas id="game" width="600" height="600" aria-label="Área de juego"></canvas>

    <div class="controls">
      <div class="controls-left">
        <button id="startBtn" class="btn">Iniciar</button>
        <button id="pauseBtn" class="btn secondary">Pausa</button>
        <button id="resetBtn" class="btn secondary">Reiniciar</button>
      </div>

      <div class="touch-controls" aria-hidden="false">
        <div class="dpad">
          <div></div>
          <button data-dir="up" title="Arriba">▲</button>
          <div></div>

          <button data-dir="left" title="Izquierda">◀</button>
          <div></div>
          <button data-dir="right" title="Derecha">▶</button>

          <div></div>
          <button data-dir="down" title="Abajo">▼</button>
          <div></div>
        </div>
        <div class="hint">Usa flechas / WASD o los botones táctiles</div>
      </div>
    </div>

    <footer>
      Controles: Flechas / WASD (desktop). En móvil aparecen botones táctiles. Guardar como <code>index.html</code>.
    </footer>
  </div>

<script>
/*
  Snake - Single file
  - Grid-based snake
  - Food appears randomly
  - Keyboard and touch controls
  - Simple speed / difficulty adjustable below
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const touchButtons = document.querySelectorAll('[data-dir]');

let gridSize = 20;       // number of cells per row/column (adjust for difficulty)
let cellSize = Math.floor(canvas.width / gridSize);
let fps = 10;            // game updates per second (increase to speed up)
let running = false;
let paused = false;
let gameInterval = null;

// Game state
let snake = [];
let dir = { x: 1, y: 0 }; // initial direction: right
let nextDir = null;       // to avoid reversing in same tick
let food = null;
let score = 0;

// Initialize / reset state
function resetGame() {
  cellSize = Math.floor(canvas.width / gridSize);
  snake = [
    { x: Math.floor(gridSize / 2) - 1, y: Math.floor(gridSize / 2) },
    { x: Math.floor(gridSize / 2) - 2, y: Math.floor(gridSize / 2) },
  ];
  dir = { x: 1, y: 0 };
  nextDir = null;
  placeFood();
  score = 0;
  scoreEl.textContent = score;
  paused = false;
  render();
}

// Place food in a random empty cell
function placeFood() {
  while (true) {
    const f = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
    if (!snake.some(s => s.x === f.x && s.y === f.y)) {
      food = f;
      return;
    }
  }
}

// Check collision with walls or self
function isCollision(head) {
  // walls: wrap-around? We'll make it collide (game over)
  if (head.x < 0 || head.y < 0 || head.x >= gridSize || head.y >= gridSize) return true;
  // self-collision
  for (let i = 0; i < snake.length; i++) {
    if (snake[i].x === head.x && snake[i].y === head.y) return true;
  }
  return false;
}

function update() {
  if (!running || paused) return;
  // apply direction
  if (nextDir) {
    // prevent reversing: if nextDir is opposite of dir, ignore
    if (!(nextDir.x === -dir.x && nextDir.y === -dir.y)) {
      dir = nextDir;
    }
    nextDir = null;
  }
  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
  if (isCollision(head)) {
    // game over
    running = false;
    clearInterval(gameInterval);
    gameOver();
    return;
  }
  // move snake
  snake.unshift(head);

  // eat food?
  if (head.x === food.x && head.y === food.y) {
    score += 10;
    scoreEl.textContent = score;
    placeFood();
    // optionally increase speed slightly every N points
    // if (score % 50 === 0) increaseSpeed();
  } else {
    snake.pop();
  }
  render();
}

function gameOver() {
  // simple message overlay
  drawBackground();
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 120);
  ctx.fillStyle = '#fff';
  ctx.font = '22px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 10);
  ctx.font = '16px system-ui, sans-serif';
  ctx.fillText('Pulsa Reiniciar para jugar otra vez', canvas.width / 2, canvas.height / 2 + 20);
}

// draw background grid, snake and food
function render() {
  drawBackground();

  // draw food
  drawCell(food.x, food.y, '#ff6b6b', true);

  // draw snake
  for (let i = 0; i < snake.length; i++) {
    const s = snake[i];
    const shade = i === 0 ? '#00ffb3' : `rgba(0, 209, 178, ${1 - i / (snake.length + 4)})`;
    drawCell(s.x, s.y, shade, i === 0);
  }
}

// clear and draw subtle grid
function drawBackground() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // background
  ctx.fillStyle = '#071226';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // optional grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= gridSize; i++) {
    const x = i * cellSize;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
    const y = i * cellSize;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
}

function drawCell(gx, gy, color, emphasize=false) {
  const margin = Math.max(1, Math.floor(cellSize * 0.08));
  const x = gx * cellSize + margin;
  const y = gy * cellSize + margin;
  const size = cellSize - margin*2;
  ctx.fillStyle = color;
  // rounded rect
  roundRect(ctx, x, y, size, size, Math.max(4, size*0.15), true, false);
  if (emphasize) {
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 2;
    roundRect(ctx, x, y, size, size, Math.max(4, size*0.15), false, true);
  }
}

// helper: rounded rectangle
function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'number') r = {tl:r, tr:r, br:r, bl:r};
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// keyboard controls
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (key === 'arrowup' || key === 'w') nextDir = { x: 0, y: -1 };
  if (key === 'arrowdown' || key === 's') nextDir = { x: 0, y: 1 };
  if (key === 'arrowleft' || key === 'a') nextDir = { x: -1, y: 0 };
  if (key === 'arrowright' || key === 'd') nextDir = { x: 1, y: 0 };
  if (key === ' '){ // space toggles pause
    togglePause();
  }
});

// touch buttons
touchButtons.forEach(btn => {
  btn.addEventListener('touchstart', ev => {
    ev.preventDefault();
    const d = btn.getAttribute('data-dir');
    setDirByName(d);
  }, {passive:false});
  btn.addEventListener('mousedown', ev => {
    ev.preventDefault();
    const d = btn.getAttribute('data-dir');
    setDirByName(d);
  });
});
function setDirByName(name){
  if (name === 'up') nextDir = { x:0, y:-1 };
  if (name === 'down') nextDir = { x:0, y:1 };
  if (name === 'left') nextDir = { x:-1, y:0 };
  if (name === 'right') nextDir = { x:1, y:0 };
}

// Buttons
startBtn.addEventListener('click', () => {
  if (!running) startGame();
});
pauseBtn.addEventListener('click', () => togglePause());
resetBtn.addEventListener('click', () => {
  running = false;
  clearInterval(gameInterval);
  resetGame();
});

// Start / stop logic
function startGame() {
  if (running) return;
  running = true;
  paused = false;
  clearInterval(gameInterval);
  gameInterval = setInterval(update, 1000 / fps);
}

function togglePause() {
  if (!running) return;
  paused = !paused;
  pauseBtn.textContent = paused ? 'Continuar' : 'Pausa';
  if (!paused) {
    // continue ticking
    // no change needed because interval still runs; update checks paused
  }
}

// responsive canvas: keep square, adjust cell size
function resizeCanvas() {
  // set canvas render size based on available width inside wrap
  const maxW = Math.min(720, window.innerWidth - 48); // small padding
  canvas.width = maxW;
  canvas.height = maxW;
  cellSize = Math.floor(canvas.width / gridSize);
  render();
}
window.addEventListener('resize', resizeCanvas);

// basic game over handler
function init() {
  resizeCanvas();
  resetGame();
}

// Utility: increase speed slightly (unused by default)
function increaseSpeed() {
  fps = Math.min(24, fps + 1);
  if (running) {
    clearInterval(gameInterval);
    gameInterval = setInterval(update, 1000 / fps);
  }
}

init();
</script>
</body>
</html>
